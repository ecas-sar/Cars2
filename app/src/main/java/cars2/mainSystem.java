/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cars2;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Map.Entry;


public class mainSystem implements dataAndStats {
    private ListCreator l;

    private VehicleCollection vc;
    private FaultCollection fc;
    private OwnerCollection oc;
    private SubSystemCollection sc;

    private HashMap<String, Vehicle> vehicleCollection;
    private HashMap<String, Fault> faultCollection;
    private HashMap<String, Owner> ownerCollection;
    private HashMap<String, SubSystem> subSystemCollection; 

    private HashMap<String, SUV> SUVCollection;
    private HashMap<String, Truck> truckCollection;
    private HashMap<String, Van> vanCollection;

    private HashMap<String, Mechanical> mechFaultCollection;
    private HashMap<String, Electrical> electFaultCollection;
    private HashMap<String, Software> softFaultCollection;

    /**
     * Constructor method intended to initialise hashmaps of data originally deserialised from json.
     * @param a: none
     * @return: Nothing, just initialises collections of vehicles, faults, owners,
     * and subsystems.
     */
    public mainSystem() throws Exception {
        l = new ListCreator();

        ArrayList<Vehicle> v = createVehList(20);
        addObject(v, "VehicleArchive", Vehicle.class);

        ArrayList<Fault> f = createFauList(20);
        addObject(f, "FaultArchive", Fault.class);

        ArrayList<Owner> o = createOwnList(20);
        addObject(o, "OwnerArchive", Owner.class);

        ArrayList<SubSystem> s = createSubList(20);
        addObject(s, "SubSystemArchive", SubSystem.class);

        vc = new VehicleCollection(l);
        fc = new FaultCollection(l);
        oc = new OwnerCollection(l);
        sc = new SubSystemCollection(l);

        vehicleCollection = vc.vehicleCollection();
        faultCollection = fc.faultCollection();
        ownerCollection = oc.ownerCollection();
        subSystemCollection = sc.subSystemCollection();

        SUVCollection = new HashMap<String, SUV>();
        truckCollection = new HashMap<String, Truck>();
        vanCollection = new HashMap<String, Van>();

        mechFaultCollection = new HashMap<String, Mechanical>();
        electFaultCollection = new HashMap<String, Electrical>();
        softFaultCollection = new HashMap<String, Software>();

        ArrayList<Association> vehFauList = createAssocList(vehicleCollection, faultCollection);
        ArrayList<Association> vehOwnList = createAssocList(vehicleCollection, ownerCollection);
        ArrayList<Association> fauSubList = createAssocList(faultCollection, subSystemCollection);
        addObject(vehFauList, "VehFauAssociation", Association.class);
        addObject(vehOwnList, "VehOwnAssociation", Association.class);
        addObject(fauSubList, "FauSubAssociation", Association.class);

        vehFauAssoc();
        vehOwnAssoc();
        fauSubAssoc();

        sortVehicleTypes();
        sortFaultTypes();

        // addVehicle(vehicleCollection.get("NGDHGDYETSHJDB"));
        // White box testing to check if addVehicle is working.
        
        // addObject(vehicleCollection.get("NGDHGDYETSHJDB"), "VehicleArchive", Vehicle.class);
        // White box testing to check if addObject is working.

        // LinkedList<Double> data = {5.6, 7.8, 10.9, 15.8, 17.6, 20.7, 24.6};
        // double medianTest = median(data);
        // White box testing to make sure that median is working properly.

        // double[][] table = new double[][] {{1.4, 6.7, 3.8, 9.5, 11.2, 13.5, 17.9}, {3.6, 7.4, 8.9, 10.8, 13.6, 14.2, 18.1}};
        // double r = aspectFaultCorrelation(table);
        // White box testing to single step through method to check if it is working properly. 
        
        /* LinkedList<Double> data  = new LinkedList<Double>();

        data.add(-200.0);
        data.add(-100.0); 
        data.add(3.0);
        data.add(4.0);
        data.add(5.0);
        data.add(7.0);
        data.add(8.0);
        data.add(9.0); 
        data.add(30.0);
        data.add(50.0);
        data.add(70.0);

        removeOutliers(data);    */
        
        // double skew = skew(data);

        // ArrayList<Vehicle> v = createVehList(20);
        // White box testing to check if vehicle creation was working properly.

        // LinkedList<Double> vehicleYOMs = createDataList(vehicleCollection, "yearOfManufacture", 8, true);
        // White box testing to check if quantatative data was working properly.
    }

    /**
     * Method intended to sort vehicle types into correct list.
     * @param a: none
     * No return, just populates vehicle subclass lists.
     */
    public void sortVehicleTypes()
    {
        for (Entry<String, Vehicle> entry: vehicleCollection.entrySet())
        {
            String vehicleType = entry.getValue().getVehicleType();
            String vehicleID = entry.getValue().getVehicleID();
            String factory = entry.getValue().getFactory();
            int yearOfManufacture = entry.getValue().getYearOfManufacture();
            String model = entry.getValue().getModel();
            ArrayList<String> f = entry.getValue().getFaultHistory();
            boolean active = entry.getValue().getActive();

            if (vehicleType.equals("SUV"))
            {
                SUVCollection.put(vehicleID, new SUV(vehicleType, vehicleID, factory, yearOfManufacture, model, f, active));
            }
            else if(vehicleType.equals("Truck"))
            {
                truckCollection.put(vehicleID, new Truck(vehicleType, vehicleID, factory, yearOfManufacture, model, f, active));
            }
            else if(vehicleType.equals("Van"))
            {
                vanCollection.put(vehicleID, new Van(vehicleType, vehicleID, factory, yearOfManufacture, model, f, active));
            }
        }
    }

    /**
     * Method intended to sort fault types into correct list.
     * @param a: none
     * No return, just populates fault subclass lists.
     */
    public void sortFaultTypes()
    {
        for(Entry<String, Fault> entry: faultCollection.entrySet())
        {
            String faultType = entry.getValue().getFaultType();
            String faultID = entry.getValue().getFaultID();
            String subSystem = entry.getValue().getSubSystemName();
            String timeStarted = entry.getValue().getTimeWindow().timeStarted();
            String timeCleared = entry.getValue().getTimeWindow().timeCleared();
            ArrayList<String> v = entry.getValue().getVehicles();

            if (faultType.equals("Mechanical"))
            {
                mechFaultCollection.put(faultID, new Mechanical(faultType, faultID, subSystem, timeStarted, timeCleared, v));
            }
            else if (faultType.equals("Electrical"))
            {
                electFaultCollection.put(faultID, new Electrical(faultType, faultID, subSystem, timeStarted, timeCleared, v));
            }
            else if (faultType.equals("Software"))
            {
                softFaultCollection.put(faultID, new Software(faultType, faultID, subSystem, timeStarted, timeCleared, v));
            }
        }
    }

    /**
     * Method intended to put vehicles in fault lists and faults in vehicle lists, associating 
     * the vehicles and faults by their ID. 
     */
    public void vehFauAssoc()
    {
        ArrayList<Association> vehFau = l.createList("VehFauAssociation", Association.class);

        for (int assocIndex = 0; assocIndex < vehFau.size(); assocIndex++)
        {
           Association valAtIndex = vehFau.get(assocIndex); 
           Vehicle v = vehicleCollection.get(valAtIndex.getfirstID());
           Fault f = faultCollection.get(valAtIndex.getsecondID());
           String VName = valAtIndex.getfirstID();
           String FName = valAtIndex.getsecondID();
           // To prevent run-time error of if it tries to access one of these methods from a null object.
           if (v != null && f != null)
           {
                v.getFaultHistory().add(FName);
                f.getVehicles().add(VName);
           }
        }
    }

    /**
     * Method intended to put the vehicles in their owner's list of vehicles.
     */
    public void vehOwnAssoc()
    {
        ArrayList<Association> vehOwn = l.createList("VehOwnAssociation", Association.class);

        for (int assocIndex = 0; assocIndex < vehOwn.size(); assocIndex++)
        {
           Association valAtIndex = vehOwn.get(assocIndex); 
           Owner o = ownerCollection.get(valAtIndex.getfirstID());
           Vehicle v  = vehicleCollection.get(valAtIndex.getsecondID());
           String VName = valAtIndex.getsecondID();
           // To prevent run-time error of if it tries to access one of these methods from a null object.
           if (v != null && o != null)
           {
                o.getOwnedVehicles().add(VName);
           }
        }
    }

    /**
     * Method intended to put the faults in the subsystems' lists. This will be useful to 
     * find out which subsystems are the most badly faulted. 
     */
    public void fauSubAssoc()
    {
        ArrayList<Association> fauSub = l.createList("FauSubAssociation", Association.class);
        for (int assocIndex = 0; assocIndex < fauSub.size(); assocIndex++)
        {
           Association valAtIndex = fauSub.get(assocIndex); 
           String SName = valAtIndex.getfirstID();
           String FName = valAtIndex.getsecondID();
           SubSystem s = subSystemCollection.get(valAtIndex.getfirstID());
           Fault f = faultCollection.get(valAtIndex.getsecondID());
           // To prevent run-time error of if it tries to access one of these methods from a null object.
           if (s != null && f != null)
           {
                s.getFaultsInThisSubSystem().add(FName);
                f.setSubSystemName(SName);
           }
        }
    }

    /** Method intended to take an object of any type, serialize it to its respective archive,
     * and then add it to the right hashmaps (with regards to superclass and type). For example,
     * if it takes a vehicle and it is an SUV, it should add it to the vehicle and SUV collections.
     * 
     * @param <T> generic
     * @param obj
     * @param nameOfArchive
     * @param clazz
     */
    public <T> void addObject(ArrayList<T> objList, String nameOfArchive, Class <T> clazz) throws IOException
    {
        l.serializeObject(nameOfArchive, objList, clazz);
    }
    
/** Method intended to return a list of randomly created vehicles.
 * @param lengthOfList
 * @return a list of vehicles.
 */
public ArrayList<Vehicle> createVehList(int lengthOfList)
{
    ArrayList<Vehicle> v = new ArrayList<Vehicle>();
    for (int i = 0; i < lengthOfList; i++)
    {
        v.add(createVehicle());
    }
    return v;
}

/** Method intended to randomly create a vehicle and randomly decide all characteristics. 
 * @return a randomly generated Vehicle
 */
public Vehicle createVehicle()
{
    String[] vehicleType = {"SUV", "Truck", "Van"};
    String[] factory = {"factory1", "factory2", "factory3"};
    String[] model = {"modelS", "modelX", "modelK"};
    int typeIndex = (int)(Math.random()*vehicleType.length - 0.1);
    int factoryIndex = (int)(Math.random()*factory.length - 0.1);
    int modelIndex = (int)(Math.random()*model.length - 0.1);
    String vehicleID = null;
    int yearOfManufacture = (int)(1970 + Math.random()*53);
    boolean active = true;

    // Randomly selects characters and forms them into a string of length 14.
    int vinLength = 14;
    vehicleID = generateString(vinLength);

    // the vehicle type, factory, and model are taken from an array of 3 and the index is randomly decided. This is done to prevent many if statements to save processing power.
    Vehicle v = new Vehicle(vehicleType[typeIndex], vehicleID, factory[factoryIndex], yearOfManufacture, model[modelIndex], new ArrayList<String>(), active);
    return v;
}

/** Method intended to create a list of randomly generated faults at a length dictated by the coder.
 * @param listLength
 * @return Arraylist of randomly generated faults. 
 */
public ArrayList<Fault> createFauList(int listLength)
{
    ArrayList<Fault> f = new ArrayList<Fault>();
    for (int i = 0; i < listLength; i++)
    {
        f.add(createFault());
    }
    return f;
}

/** Method intended to randomly generate a fault object.
 * @return A fault object
 */
public Fault createFault()
{
    int finLength = 14;
    String[] faultTypes = {"Mechanical", "Electrical", "Software"};
    int typeIndex = (int)(Math.random()*faultTypes.length - 0.1);
    String faultID = generateString(finLength);
    String timeStarted = createTime();
    String timeEnded = createTime();
    Fault f = new Fault(faultTypes[typeIndex], faultID, "", timeStarted, timeEnded, new ArrayList<String>());
    return f;
}

/** Method intended to randomly generate a time in day:month:year hour:minute format.
 * @return Time String
 */
public String createTime()
{
    int year = (int)(1970 + Math.random()*53);
    int month = (int)(1 + Math.random()*11);
    int day = 0;
    if (month == 2)
    {
        if (year % 4 == 0)
        {
            day = (int)(1 + Math.random()*28);
        }
        else day = (int)(1 + Math.random()*27);
    }
    else if (month % 2 == 1)
    {
        day = (int)(1 + Math.random()*30);
    }
    else 
    {
        day = (int)(1 + Math.random()*29);
    }

    int hour = (int)(Math.random()*24);
    int minutes = (int)(Math.random()*60);

    String time = Integer.toString(day) + ":" + Integer.toString(month) + ":" + Integer.toString(year) + " " + Integer.toString(hour) + ":" + Integer.toString(minutes);
    return time;
}

/** Method intended to create a list of owners as long as the parameter passed in. 
 * @param listLength
 * @return list of owners
 */
public ArrayList<Owner> createOwnList(int listLength)
{
    ArrayList<Owner> o = new ArrayList<Owner>();

    for (int i = 0; i < listLength; i++)
    {
        o.add(createOwner());
    }
    return o;
}

/** Method intended to randomly generate an owner with given attributes. 
 * @return a randomly generated owner.
 */
public Owner createOwner()
{
    String ownerID = generateString(14);
    String name = generateString(5) + " " + generateString(6);
    String homeAddress = generateString(10);
    String emailAddress = name.substring(0, 1) + name.substring(6, name.length()) + "@gmail.com";
    Owner o = new Owner(ownerID, name, homeAddress, emailAddress);
    return o;
}

public ArrayList<SubSystem> createSubList(int listLength)
{
    ArrayList<SubSystem> s = new ArrayList<SubSystem>();
    String[] names = {"Wheel", "Engine", "Speed camera", "Battery", "Headlights"};
    for (int i = 0; i < listLength; i++)
    {
        String subID = generateString(14);
        int nameIndex = (int)(Math.random()*names.length - 0.1);
        s.add(new SubSystem(subID, names[nameIndex]));
    }
    return s;
}

/** Method intended to create an association object list so that all objects can be associated properly later. 
 * @param <E>
 * @param <T>
 * @return an association list
 */
public <E, T> ArrayList<Association> createAssocList(HashMap<String, E> giverMap, HashMap<String, T> targetMap)
{
    ArrayList<Association> a = new ArrayList<Association>(); 
    // Converts key sets of both hashmaps into arrays.
    String[] keysOfGiverMap = giverMap.keySet().toArray(new String[0]);
    String[] keysOfTargetMap = targetMap.keySet().toArray(new String[0]);

    // Shuffles all lists as a more random set of association objects tests more situations.
    List<String> shuffledGiverList = Arrays.asList(keysOfGiverMap);
    List<String> shuffledTargetList = Arrays.asList(keysOfTargetMap);
    Collections.shuffle(shuffledGiverList);
    Collections.shuffle(shuffledTargetList);
    String[] shuffledGiverArray = shuffledGiverList.toArray(new String[0]);
    String[] shuffledTargetArray = shuffledTargetList.toArray(new String[0]);

    int giverIndex = 0;
    int targetIndex = 0;
    while (giverIndex < shuffledGiverArray.length || targetIndex < shuffledTargetArray.length)
    {
        String fid = shuffledGiverArray[giverIndex];
        String sid = shuffledTargetArray[targetIndex];

        /* If statement to prevent out of bounds error. This will make sure that the computer
         * can only iterate through the giver map once, but it can iterate through the target map multiple times. 
         */
        if (giverIndex >= shuffledGiverArray.length)
        {
            fid = null;
        }
        else if (targetIndex == shuffledTargetArray.length)
        {
            targetIndex = 0;
        }

        a.add(new Association(fid, sid));
        giverIndex++;
        targetIndex++;
    }

    return a;
}

/** Method intended to create a string, randomising each of its characters. 
 * @param length
 * @return String
 */
public String generateString(int length)
{
    StringBuilder sb = new StringBuilder();
    Random random = new Random();
    for (int i = 0; i < length; i++)
    {
        sb.append((char) (random.nextInt(26) + 'A'));
    }   
    String toReturn = sb.toString();
    return toReturn;
}

    /**
     * Method intended to find the vehicle with the most faults.
     * @param a: ArrayList of vehicles
     * @return: The vehicle with the most faults.
     */
    public Vehicle mostFaults(ArrayList<Vehicle> v) {
        return null;

    }

    /**
     * Method intended to return a list of all vehicles that have active faults.
     * @param a: Arraylist of vehicles
     * @return: List of vehicles with active faults.
     */
    public ArrayList<Vehicle> vehiclesWithActiveFaults(ArrayList<Vehicle> v) {
        return v;

    }

    /**
     * Method intended to return a list of all vehicles that have a specific type of
     * fault.
     * @param a: Arraylist
     * @param b: Fault
     * @return: List of vehicles with that type of fault.
     */
    public ArrayList<Vehicle> vehiclesWithTypeOfFault(ArrayList<Vehicle> v, Fault f) {
        return v;

    }

    /**
     * Method intended to find the most common fault.
     * @param a: ArrayList of faults
     * @return: The most common fault.
     */
    public Fault mostCommonFault(ArrayList<Fault> f) {
        return null;

    }

    /**
     * Method intended to find the rarest fault.
     * @param a: ArrayList of faults
     * @return: The rarest fault.
     */
    public Fault rarestFault(ArrayList<Fault> f) {
        return null;

    }

    /**
     * Method intended to return how many average faults per time window
     * @param a: Arraylist of faults
     * @param b: int
     * @return: the fault density in faults per time window.
     */
    public int faultDensity(ArrayList<Fault> f, TimeWindow timeWindow) {
        return 0;
    }

    /**
     * Method intended to find the correlation between the aspect and the fault data
     * and the fault data when aspect is a string array
     * This method won't return r as that can't be calculated here. Instead, an
     * example of what this method would return would be is
     * if the aspect is the factory from which the car was manufactured, the method
     * will return which factory made the cars with the
     * most faults.
     * @param a: String array
     * @param b: int array
     * @return: Whichever factory, model, or anything else the aspect could be, has
     * the most faults.
     */
    public String aspectFaultDataQualatitive(String[] aspect, int[] faultData) {
        return null;

    }

    /**
     * Method intended to find the subsystem of cars with the most faults
     * @param a: Arraylist of subsystems.
     * @return: the subsystem with the most faults.
     */
    public SubSystem mostBadlyFaultedSubSystem(ArrayList<SubSystem> ss) {
        return null;
    }


     @Override
     public <E, T> LinkedList<T> createDataList(HashMap<String, E> dataGiver, String dataName, int numOfSamples, boolean systematic) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        LinkedList<T> toReturn = new LinkedList<T>();
        @SuppressWarnings("unchecked")
        E[] valsOfMap = (E[]) dataGiver.values().toArray();
        // samplingInterval used for systematic smapling but can help calculate starting point also. 
            int samplingInterval = valsOfMap.length/numOfSamples;
            int startingPoint = (int) (Math.random()*numOfSamples);
            int EIndex = startingPoint; 
        for (int dataIndex = 0; dataIndex < numOfSamples; dataIndex++)
        {
            if (!systematic)
            {
                // Will do random sampling if systematic is false.
                // Checked with client, the probablilty that a sample is chosen twice is negligibly low.
                EIndex = (int) (Math.random()*valsOfMap.length);
            }
            else
            {
                if (dataIndex != 0)
                {
                    EIndex += samplingInterval;
                }
            }
            ArrayList<Method> accessorMethods = accessorMethodsFromObject(valsOfMap[EIndex]);
            for (int methodIndex = 0; methodIndex < accessorMethods.size(); methodIndex++)
            {
                Method currentMethod = accessorMethods.get(methodIndex);
                String methodName = currentMethod.getName().toUpperCase();
                String dName = dataName.toUpperCase(); 
                if (methodName.contains(dName))
                {
                    Object attributeValue = currentMethod.invoke(valsOfMap[EIndex]);
                    @SuppressWarnings("unchecked")
                    T attributeValueGeneric = (T) attributeValue;
                    toReturn.add(attributeValueGeneric);
                }
            }
        }
        return toReturn;
    }

    /** Method intended to take any object and return a list of its accessor methods. 
     * @param <E>
     * @param o
     * @return ArrayList<Method>
     */
    public <E> ArrayList<Method> accessorMethodsFromObject(E o)
    {
        // Gets the class of the object.
        Class<?> objClass = o.getClass();

        // Takes the methods of the object.
        Method[] allMethods =  objClass.getDeclaredMethods();

        /* Creates a new list that will contain the accessor methods of the object.
        *  It is a list so that the size can be changed to adjust how many accessor methods are in the object. 
        */
        ArrayList<Method> accessorMethods = new ArrayList<Method>();

        // Iterates through array of all methods.
        for (int methodIndex = 0; methodIndex < allMethods.length; methodIndex++)
        {
            // The method the list is currently pointing to.
            Method currentMethod = allMethods[methodIndex];
            // Only adds the the new list if it is a accessor method. 
            if (isAccessor(currentMethod))
            {
                accessorMethods.add(currentMethod);
            }
        }
        return accessorMethods;
    }
   
    
    /** Method intended to check if the method passed in is a getter method.
     * @param method
     * @return boolean
     */
    public boolean isAccessor(Method method) 
    {
        String methodName = method.getName();
        return methodName.startsWith("get") && !methodName.equals("getClass") && method.getParameterCount() == 0;
    }

    @Override
    public double mean(LinkedList<Double> data) 
    {
        double sum = Double.MIN_VALUE;
        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++)
        {
            sum += data.get(dataIndex);
        }
        double result = sum/data.size();
        return result;
    }

    @Override
    public double standardDeviation(LinkedList<Double> data) 
    {
        double sum = Double.MIN_VALUE;
        double mean = mean(data);
        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++)
        {
            sum += Math.pow((data.get(dataIndex) - mean), 2.0);
        }    
        return Math.sqrt(sum/(data.size() - 1.0));
    }

    @Override
    public double median(LinkedList<Double> data)
     {
        /*
         * The if statement states that if the length of the list is an odd number, it
         * will use the middle value, and if the length of the list is an even number,
         * it will find the mean of the 2 values closest to the middle. 
         */ 
        if (data.size() % 2 != 0)
        {
            return (data.get(data.size()/2));
        }
        else
        {
            return (data.get((data.size()/2)-1) + (data.get(data.size()/2)))/2;
        }
    }

    @Override
    public double mode(LinkedList<Double> data) {
        // Hashmap stores the data point as the key and its frequency as its value.
        HashMap<Double, Double> frequencyList = new HashMap<Double, Double>();

        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++)
        {
            double thisData = data.get(dataIndex);
            frequencyList.put(thisData, frequencyList.getOrDefault(thisData, 0.0) + 1.0);
        }

        double maxFrequency = Double.MIN_VALUE;
        double mode = Double.MIN_VALUE;

        for (HashMap.Entry<Double, Double> entry : frequencyList.entrySet())
        {
            double value = entry.getKey();
            double freq = entry.getValue();
            if (freq > maxFrequency)
            {
                maxFrequency = freq;
                mode = value;
            }
        }
        if (!allSameVals(frequencyList))
        {
            return mode;
        }
        else return -1;
    }

    @Override
    public double aspectFaultCorrelation(LinkedList<Double> dataX, LinkedList<Double> dataY) {
        double sumNum = Double.MIN_VALUE;
        double sumDenX = Double.MIN_VALUE;
        double sumDenY = Double.MIN_VALUE;
        double meanX = mean(dataX);
        double meanY = mean(dataY);
        for (int dataIndex = 0; dataIndex < dataX.size(); dataIndex++)
        {
            double xCalc1 = (dataX.get(dataIndex) - meanX);
            double yCalc1 = (dataY.get(dataIndex) - meanY);
            double totalOfAll1 = xCalc1*yCalc1;
            sumNum += totalOfAll1;
            double xCalc2 = Math.pow(xCalc1, 2.0);
            sumDenX += xCalc2;
            double yCalc2 = Math.pow(yCalc1, 2.0);
            sumDenY += yCalc2;
        }
        double result = sumNum/(Math.sqrt(sumDenX*sumDenY));
        return result; 
    }

    @Override
    public double skew(LinkedList<Double> data) {
        double sum = Double.MIN_VALUE;
        double mean = mean(data);
        double n = data.size();
        for (int dataIndex = 0; dataIndex < n; dataIndex++)
        {
            double numerator = data.get(dataIndex) - mean;
            double denominator = standardDeviation(data);
            double quotient = numerator/denominator;
            double toAdd = Math.pow(quotient, 3);
            sum += toAdd;
        }

        double skew = sum*(n/((n-1)*(n-2)));
        return skew;
    }

    @Override
    public String regressionEquation(LinkedList<Double> dataX, LinkedList<Double> dataY) {
        double meanX = mean(dataX);
        double meanY = mean(dataY);
        double b = aspectFaultCorrelation(dataX, dataY)*(standardDeviation(dataY)/standardDeviation(dataX));
        double a = meanY - b*meanX;
        String equation = "y = " + b + "x + " + a;
        return equation; 
    }

    @Override
    public void removeOutliers(LinkedList<Double> data) {
        boolean noMoreOutliers = false;
        while (!noMoreOutliers)
        {
            double firstPoint = data.getFirst();
            double lastPoint = data.getLast();
            if (!isOutlier(data, firstPoint) && !isOutlier(data, lastPoint))
            {
                noMoreOutliers = true;
            }
            else
            {
                if (isOutlier(data, firstPoint))
                {
                    data.removeFirst();
                }
                if (isOutlier(data, lastPoint))
                {
                    data.removeLast();
                }
            }
        }
    }

    @Override
    public boolean isOutlier(LinkedList<Double> data, double dataPoint) {
        double lowerBound = mean(data) - (2*standardDeviation(data));
        double upperBound = mean(data) + (2*standardDeviation(data));
        return (dataPoint > upperBound) ^ (dataPoint < lowerBound);        
    }

    /** Method intended to state whether a hasmpa hase the same values for all keys.
     * @param <K>
     * @param <V>
     * @param map
     * @return Whether all values in this map are the same or not.
     */
    public <K, V> boolean allSameVals(Map<K, V> map)
    {
        if (map.isEmpty())
        {
            return true;
        }

        V firstVal = map.values().iterator().next();
        for (V value: map.values())
        {
            if (!value.equals(firstVal))
            {
                return false;
            }
        }
        return true;
    }
}
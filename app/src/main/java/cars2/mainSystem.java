/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cars2;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;

import java.util.Map.Entry;


public class mainSystem implements dataAndStats {
    private ListCreator l;

    private VehicleCollection vc;
    private FaultCollection fc;
    private OwnerCollection oc;
    private SubSystemCollection sc;

    private HashMap<String, Vehicle> vehicleCollection;
    private HashMap<String, Fault> faultCollection;
    private HashMap<String, Owner> ownerCollection;
    private HashMap<String, SubSystem> subSystemCollection; 

    private HashMap<String, SUV> SUVCollection;
    private HashMap<String, Truck> truckCollection;
    private HashMap<String, Van> vanCollection;

    private HashMap<String, Mechanical> mechFaultCollection;
    private HashMap<String, Electrical> electFaultCollection;
    private HashMap<String, Software> softFaultCollection;

    /**
     * Constructor method intended to initialise hashmaps of data originally deserialised from json.
     * @param a: none
     * @return: Nothing, just initialises collections of vehicles, faults, owners,
     * and subsystems.
     */
    public mainSystem() throws Exception {
        l = new ListCreator();

        ArrayList<Vehicle> v = createVehList(20);
        addObject(v, "VehicleArchive", Vehicle.class);

        ArrayList<Fault> f = createFauList(20);
        addObject(f, "FaultArchive", Fault.class);

        ArrayList<Owner> o = createOwnList(20);
        addObject(o, "OwnerArchive", Owner.class);

        ArrayList<SubSystem> s = createSubList(20);
        addObject(s, "SubSystemArchive", SubSystem.class);

        vc = new VehicleCollection(l);
        fc = new FaultCollection(l);
        oc = new OwnerCollection(l);
        sc = new SubSystemCollection(l);

        vehicleCollection = vc.vehicleCollection();
        faultCollection = fc.faultCollection();
        ownerCollection = oc.ownerCollection();
        subSystemCollection = sc.subSystemCollection();

        SUVCollection = new HashMap<String, SUV>();
        truckCollection = new HashMap<String, Truck>();
        vanCollection = new HashMap<String, Van>();

        mechFaultCollection = new HashMap<String, Mechanical>();
        electFaultCollection = new HashMap<String, Electrical>();
        softFaultCollection = new HashMap<String, Software>();

        ArrayList<Association> vehFauList = createAssocList(vehicleCollection, faultCollection);
        ArrayList<Association> vehOwnList = createAssocList(vehicleCollection, ownerCollection);
        ArrayList<Association> fauSubList = createAssocList(faultCollection, subSystemCollection);
        addObject(vehFauList, "VehFauAssociation", Association.class);
        addObject(vehOwnList, "VehOwnAssociation", Association.class);
        addObject(fauSubList, "FauSubAssociation", Association.class);

        vehFauAssoc();
        vehOwnAssoc();
        fauSubAssoc();

        sortVehicleTypes();
        sortFaultTypes();

        // addVehicle(vehicleCollection.get("NGDHGDYETSHJDB"));
        // White box testing to check if addVehicle is working.
        
        // addObject(vehicleCollection.get("NGDHGDYETSHJDB"), "VehicleArchive", Vehicle.class);
        // White box testing to check if addObject is working.

        // LinkedList<Double> data = {5.6, 7.8, 10.9, 15.8, 17.6, 20.7, 24.6};
        // double medianTest = median(data);
        // White box testing to make sure that median is working properly.

        // double[][] table = new double[][] {{1.4, 6.7, 3.8, 9.5, 11.2, 13.5, 17.9}, {3.6, 7.4, 8.9, 10.8, 13.6, 14.2, 18.1}};
        // double r = aspectFaultCorrelation(table);
        // White box testing to single step through method to check if it is working properly. 
        
        /* LinkedList<Double> data  = new LinkedList<Double>();

        data.add(-200.0);
        data.add(-100.0); 
        data.add(3.0);
        data.add(4.0);
        data.add(5.0);
        data.add(7.0);
        data.add(8.0);
        data.add(9.0); 
        data.add(30.0);
        data.add(50.0);
        data.add(70.0);

        removeOutliers(data);    */
        
        // double skew = skew(data);

        // ArrayList<Vehicle> v = createVehList(20);
        // White box testing to check if vehicle creation was working properly.

        // LinkedList<Double> vehicleYOMs = createDataList(vehicleCollection, "yearOfManufacture", 8, true);
        // White box testing to check if sampling method was working properly.
    }

    /**
     * Method intended to sort vehicle types into correct list.
     * @param a: none
     * No return, just populates vehicle subclass lists.
     */
    public void sortVehicleTypes()
    {
        for (Entry<String, Vehicle> entry: vehicleCollection.entrySet())
        {
            Vehicle currentVehicle = entry.getValue();
            String vehicleType = currentVehicle.getVehicleType();
            String vehicleID = currentVehicle.getVehicleID();

            if (vehicleType.equals("SUV"))
            {
                SUV suv = (SUV) currentVehicle;
                SUVCollection.put(vehicleID, suv);
            }
            else if(vehicleType.equals("Truck"))
            {
                Truck truck = (Truck) currentVehicle;
                truckCollection.put(vehicleID, truck);
            }
            else if(vehicleType.equals("Van"))
            {
                Van van = (Van) currentVehicle;
                vanCollection.put(vehicleID, van);
            }
        }
    }

    /**
     * Method intended to sort fault types into correct list.
     * @param a: none
     * No return, just populates fault subclass lists.
     */
    public void sortFaultTypes()
    {
        for(Entry<String, Fault> entry: faultCollection.entrySet())
        {
            Fault currentFault = entry.getValue();
            String faultType = currentFault.getFaultType();
            String faultID = currentFault.getFaultID();

            if (faultType.equals("Mechanical"))
            {
                Mechanical mech = (Mechanical) currentFault; 
                mechFaultCollection.put(faultID, mech);
            }
            else if (faultType.equals("Electrical"))
            {
                Electrical elect = (Electrical) currentFault;
                electFaultCollection.put(faultID, elect);
            }
            else if (faultType.equals("Software"))
            {
                Software soft = (Software) currentFault;
                softFaultCollection.put(faultID, soft);
            }
        }
    }

    /**
     * Method intended to put vehicles in fault lists and faults in vehicle lists, associating 
     * the vehicles and faults by their ID. 
     */
    public void vehFauAssoc()
    {
        ArrayList<Association> vehFau = l.createList("VehFauAssociation", Association.class);

        for (int assocIndex = 0; assocIndex < vehFau.size(); assocIndex++)
        {
           Association valAtIndex = vehFau.get(assocIndex); 
           Vehicle v = vehicleCollection.get(valAtIndex.getfirstID());
           Fault f = faultCollection.get(valAtIndex.getsecondID());
           String VName = valAtIndex.getfirstID();
           String FName = valAtIndex.getsecondID();
           // To prevent run-time error of if it tries to access one of these methods from a null object.
           if (v != null && f != null)
           {
                v.getFaultHistory().add(FName);
                f.getVehicles().add(VName);
           }
        }
    }

    /**
     * Method intended to put the vehicles in their owner's list of vehicles.
     */
    public void vehOwnAssoc()
    {
        ArrayList<Association> vehOwn = l.createList("VehOwnAssociation", Association.class);

        for (int assocIndex = 0; assocIndex < vehOwn.size(); assocIndex++)
        {
           Association valAtIndex = vehOwn.get(assocIndex); 
           Vehicle v  = vehicleCollection.get(valAtIndex.getfirstID());
           Owner o = ownerCollection.get(valAtIndex.getsecondID());
           String VName = valAtIndex.getfirstID();
           String OName = valAtIndex.getsecondID();
           // To prevent run-time error of if it tries to access one of these methods from a null object.
           if (v != null && o != null)
           {
                o.getOwnedVehicles().add(VName);
                v.setOwnerID(OName);
           }
        }
    }

    /**
     * Method intended to put the faults in the subsystems' lists. This will be useful to 
     * find out which subsystems are the most badly faulted. 
     */
    public void fauSubAssoc()
    {
        ArrayList<Association> fauSub = l.createList("FauSubAssociation", Association.class);
        for (int assocIndex = 0; assocIndex < fauSub.size(); assocIndex++)
        {
           Association valAtIndex = fauSub.get(assocIndex); 
           String FName = valAtIndex.getfirstID();
           String SName = valAtIndex.getsecondID();
           Fault f = faultCollection.get(FName);
           SubSystem s = subSystemCollection.get(SName);
           // To prevent run-time error of if it tries to access one of these methods from a null object.
           if (s != null && f != null)
           {
                s.getFaultsInThisSubSystem().add(FName);
                f.setSubSystemName(s.getSubSystemName());
           }
        }
    }

    /** Method intended to take an object of any type, serialize it to its respective archive,
     * and then add it to the right hashmaps (with regards to superclass and type). For example,
     * if it takes a vehicle and it is an SUV, it should add it to the vehicle and SUV collections.
     * 
     * @param <T> generic
     * @param obj
     * @param nameOfArchive
     * @param clazz
     */
    public <T> void addObject(ArrayList<T> objList, String nameOfArchive, Class <T> clazz) throws IOException
    {
        l.serializeObject(nameOfArchive, objList, clazz);
    }
    
/** Method intended to return a list of randomly created vehicles.
 * @param lengthOfList
 * @return a list of vehicles.
 */
public ArrayList<Vehicle> createVehList(int lengthOfList)
{
    ArrayList<Vehicle> v = new ArrayList<Vehicle>();
    for (int i = 0; i < lengthOfList; i++)
    {
        v.add(createVehicle());
    }
    return v;
}

/** Method intended to randomly create a vehicle and randomly decide all characteristics. 
 * @return a randomly generated Vehicle
 */
public Vehicle createVehicle()
{
    String[] vehicleTypes = {"SUV", "Truck", "Van"};
    String[] factories = {"factory1", "factory2", "factory3"};
    String[] models = {"modelS", "modelX", "modelK"};
    int typeIndex = (int)(Math.random()*vehicleTypes.length - 0.1);
    int factoryIndex = (int)(Math.random()*factories.length - 0.1);
    int modelIndex = (int)(Math.random()*models.length - 0.1);
    String vehicleType = vehicleTypes[typeIndex];
    String factory = factories[factoryIndex];
    String model = models[modelIndex];
    String vehicleID = null;
    int yearOfManufacture = (int)(1970 + Math.random()*53);
    boolean active = true;

    // Randomly selects characters and forms them into a string of length 14.
    int vinLength = 14;
    vehicleID = generateString(vinLength);

    // the vehicle type, factory, and model are taken from an array of 3 and the index is randomly decided. This is done to prevent many if statements to save processing power.
    Vehicle v = new Vehicle(vehicleType, vehicleID, factory, yearOfManufacture, model, new ArrayList<String>(), "", active);
    if (vehicleType.equals("SUV"))
    {
        SUV suv = createSUV(v);
        return suv;
    }
    else if (vehicleType.equals("Truck"))
    {
        Truck truck = createTruck(v);
        return truck;
    }
    else
    {
        Van van = createVan(v);
        return van;
    }
}

/** Method intended to randomly generate data specific to an SUV given the Vehicle v.
 * @param v
 * @return SUV
 */
public SUV createSUV(Vehicle v)
{
    int[] numSeatsOptions = {5, 7, 8};
    int optionIndex = (int) (Math.random()*2);
    int averageNumPassengers = (int) (Math.random()*7 + 1);
    SUV suv = new SUV(v.getVehicleType(), v.getVehicleID(), v.getFactory(), v.getYearOfManufacture(), v.getModel(), v.getFaultHistory(), v.getOwnerID(), v.getActive(), numSeatsOptions[optionIndex], averageNumPassengers);
    return suv; 
}

/** Method intended to randomly generate data specific to a Truck given the Vehile v.
 * @param v
 * @return Truck
 */
public Truck createTruck(Vehicle v)
{
    double[] maxMassInBackOptions = {25.0, 50.0, 75.0};
    int massIndex = (int) (Math.random()*2);
    double averageMassPerDay = Math.random()*15;
    Truck truck = new Truck(v.getVehicleType(), v.getVehicleID(), v.getFactory(), v.getYearOfManufacture(), v.getModel(), v.getFaultHistory(), v.getOwnerID(), v.getActive(), maxMassInBackOptions[massIndex], averageMassPerDay);
    return truck;
}

/** Method intended to randomly generate data specific to a Van given the Vehicle v.
 * @param v
 * @return Van
 */
public Van createVan(Vehicle v)
{
    double[] maxCargoMassOptions = {1000.0, 1500.0, 2000.0};
    int massIndex = (int) (Math.random()*2);
    double averageCargoPerDay = Math.random()*50;
    double storageVolume = Math.random()*60;
    Van van = new Van(v.getVehicleType(), v.getVehicleID(), v.getFactory(), v.getYearOfManufacture(), v.getModel(), v.getFaultHistory(), v.getOwnerID(), v.getActive(), maxCargoMassOptions[massIndex], averageCargoPerDay, storageVolume);
    return van;
}

/** Method intended to create a list of randomly generated faults at a length dictated by the coder.
 * @param listLength
 * @return Arraylist of randomly generated faults. 
 */
public ArrayList<Fault> createFauList(int listLength)
{
    ArrayList<Fault> f = new ArrayList<Fault>();
    for (int i = 0; i < listLength; i++)
    {
        f.add(createFault());
    }
    return f;
}

/** Method intended to randomly generate a fault object.
 * @return A fault object
 */
public Fault createFault()
{
    int finLength = 14;
    String[] faultTypes = {"Mechanical", "Electrical", "Software"};
    int typeIndex = (int)(Math.random()*faultTypes.length - 0.1);
    String faultType = faultTypes[typeIndex];
    String faultID = generateString(finLength);
    String timeStarted = createTime();
    String timeEnded = createTime();
    boolean active = true;
    Fault f = new Fault(faultType, faultID, "", timeStarted, timeEnded, new ArrayList<String>(), active);
    if (faultType.equals("Mechanical"))
    {
        Mechanical mech = createMechanical(f);
        return mech;
    }
    else if (faultType.equals("Electrical"))
    {
        Electrical elect = createElectrical(f);
        return elect;
    }
    else
    {
        Software soft = createSoftware(f);
        return soft;
    }
}

/** Method intended to randomly generate data specific to mechanical faults given the Fault f.
 * @param f
 * @return A mechanical fault
 */
public Mechanical createMechanical(Fault f)
{
    String systemName = generateString((int) (Math.random()*8));
    int partNumber = (int) (Math.random()*15);
    String[] failureTypes = {"Abrasion", "Corrosion", "Shock loading", "Creep", "Fatigue"};
    int failureIndex = (int) (Math.random()*failureTypes.length - 0.1);
    String failureType = failureTypes[failureIndex];
    Mechanical mech = new Mechanical(f.getFaultType(), f.getFaultID(), f.getSubSystemName(), f.getTimeWindow().getTimeStarted(), f.getTimeWindow().getTimeCleared(), f.getVehicles(), f.getActive(), systemName, partNumber, failureType);
    return mech;
}

/** Method intended to randomly generate data specific to electrical faults given the fault f.
 * @param f
 * @return An electrical fault
 */
public Electrical createElectrical(Fault f)
{
    int modulePartNumber = (int) (Math.random()*15);
    int numModulesAffected = (int) (Math.random()*15);
    String DBCForOBT = generateString(10);
    Electrical elect = new Electrical(f.getFaultType(), f.getFaultID(), f.getSubSystemName(), f.getTimeWindow().getTimeStarted(), f.getTimeWindow().getTimeCleared(), f.getVehicles(), f.getActive(), modulePartNumber, numModulesAffected, DBCForOBT);
    return elect;
}

/** Method intended to randomly generate data specific to software faults given the fault f.
 * @param f
 * @return A software fault.
 */
public Software createSoftware(Fault f)
{
    boolean runTime = false;
    boolean majorOrMinor = false;
    if (((int) (Math.random()*2)) == 1)
    {
        runTime = true;
        majorOrMinor = true;
    } 
    int numLinesInClass = (int) (Math.random()*1500);
    String severity = generateString(9);
    Software soft = new Software(f.getFaultType(), f.getFaultID(), f.getSubSystemName(), f.getTimeWindow().getTimeStarted(), f.getTimeWindow().getTimeCleared(), f.getVehicles(), f.getActive(), runTime, numLinesInClass, majorOrMinor, severity);
    return soft;
}

/** Method intended to randomly generate a time in day:month:year hour:minute format.
 * @return Time String
 */
public String createTime()
{
    int year = (int)(1970 + Math.random()*53);
    int month = (int)(1 + Math.random()*11);
    int day = 0;
    if (month == 2)
    {
        if (year % 4 == 0)
        {
            day = (int)(1 + Math.random()*28);
        }
        else day = (int)(1 + Math.random()*27);
    }
    else if (month % 2 == 1)
    {
        day = (int)(1 + Math.random()*30);
    }
    else 
    {
        day = (int)(1 + Math.random()*29);
    }

    int hour = (int)(Math.random()*24);
    int minutes = (int)(Math.random()*60);
    int seconds = (int)(Math.random()*60);

    String format = "%02d";

    String time = Integer.toString(year) + "-" + String.format(format, month) + "-" + String.format(format, day) + "T" + String.format(format, hour) + ":" + String.format(format, minutes) + ":" + String.format(format, seconds);
    return time;
}

/** Method intended to create a list of owners as long as the parameter passed in. 
 * @param listLength
 * @return list of owners
 */
public ArrayList<Owner> createOwnList(int listLength)
{
    ArrayList<Owner> o = new ArrayList<Owner>();

    for (int i = 0; i < listLength; i++)
    {
        o.add(createOwner());
    }
    return o;
}

/** Method intended to randomly generate an owner with given attributes. 
 * @return a randomly generated owner.
 */
public Owner createOwner()
{
    String ownerID = generateString(14);
    String name = generateString(5) + " " + generateString(6);
    String homeAddress = generateString(10);
    String emailAddress = name.substring(0, 1) + name.substring(6, name.length()) + "@gmail.com";
    Owner o = new Owner(ownerID, name, homeAddress, emailAddress);
    return o;
}

public ArrayList<SubSystem> createSubList(int listLength)
{
    ArrayList<SubSystem> s = new ArrayList<SubSystem>();
    String[] names = {"Wheel", "Engine", "Speed camera", "Battery", "Headlights"};
    for (int i = 0; i < listLength; i++)
    {
        String subID = generateString(14);
        int nameIndex = (int)(Math.random()*names.length - 0.1);
        s.add(new SubSystem(subID, names[nameIndex]));
    }
    return s;
}

/** Method intended to create an association object list so that all objects can be associated properly later. 
 * @param <E>
 * @param <T>
 * @return an association list
 */
public <E, T> ArrayList<Association> createAssocList(HashMap<String, E> giverMap, HashMap<String, T> targetMap)
{
    ArrayList<Association> a = new ArrayList<Association>(); 
    // Converts key sets of both hashmaps into arrays.
    String[] keysOfGiverMap = giverMap.keySet().toArray(new String[0]);
    String[] keysOfTargetMap = targetMap.keySet().toArray(new String[0]);

    // Shuffles all lists as a more random set of association objects tests more situations.
    List<String> shuffledGiverList = Arrays.asList(keysOfGiverMap);
    List<String> shuffledTargetList = Arrays.asList(keysOfTargetMap);
    Collections.shuffle(shuffledGiverList);
    Collections.shuffle(shuffledTargetList);
    String[] shuffledGiverArray = shuffledGiverList.toArray(new String[0]);
    String[] shuffledTargetArray = shuffledTargetList.toArray(new String[0]);

    int giverIndex = 0;
    int targetIndex = 0;
    while (giverIndex < shuffledGiverArray.length && targetIndex < shuffledTargetArray.length)
    {
        String fid = shuffledGiverArray[giverIndex];
        String sid = shuffledTargetArray[targetIndex];

        /* If statement to prevent out of bounds error. This will make sure that the computer
         * can only iterate through the giver map once, but it can iterate through the target map multiple times. 
         */
        if (giverIndex >= shuffledGiverArray.length)
        {
            fid = null;
        }
        else if (targetIndex == shuffledTargetArray.length)
        {
            targetIndex = 0;
        }

        a.add(new Association(fid, sid));
        giverIndex++;
        targetIndex++;
    }

    return a;
}

/** Method intended to create a string, randomising each of its characters. 
 * @param length
 * @return String
 */
public String generateString(int length)
{
    StringBuilder sb = new StringBuilder();
    Random random = new Random();
    for (int i = 0; i < length; i++)
    {
        sb.append((char) (random.nextInt(26) + 'A'));
    }   
    String toReturn = sb.toString();
    return toReturn;
}

    /**
     * Method intended to find the vehicle with the most faults.
     * @param 
     * @return: The vehicle with the most faults.
     */
    public Vehicle mostFaults() {
        int maxNumFaults = Integer.MIN_VALUE;
        Vehicle withMostFaults = null;
        for (Entry<String, Vehicle> entry: vehicleCollection.entrySet())
        {
            Vehicle currentVehicle = entry.getValue();
            int currentVehicleNumFaults = currentVehicle.getFaultHistory().size();
            if (currentVehicleNumFaults > maxNumFaults)
            {
                maxNumFaults = currentVehicleNumFaults;
                withMostFaults = currentVehicle;
            }
        }
        return withMostFaults;
    }

    /**
     * Method intended to return a list of all vehicles that have active faults.
     * @param 
     * @return: List of vehicles with active faults.
     */
    public ArrayList<Vehicle> vehiclesWithActiveFaults() {
        ArrayList<Vehicle> vehiclesWithActiveFaults = new ArrayList<Vehicle>();
        for (Entry<String, Vehicle> entry: vehicleCollection.entrySet())
        {
            Vehicle currentVehicle = entry.getValue();
            ArrayList<String> currentVehicleFaultHistory = currentVehicle.getFaultHistory();
            // Iterates through vehicles fault history.
            for (int faultIndex = 0; faultIndex < currentVehicleFaultHistory.size(); faultIndex++)
            {
                // Retrieves the fault from the fault collection based on the ID.
                Fault currentFault = faultCollection.get(currentVehicleFaultHistory.get(faultIndex));
                // If any faults are active, the vehicle would get added to the list to be returned.
                if (currentFault.getActive())
                {
                    vehiclesWithActiveFaults.add(currentVehicle);
                }
            }
        }
        return vehiclesWithActiveFaults;
    }

    /**
     * Method intended to return a list of all vehicles that have a specific type of
     * fault.
     * @param b: String
     * @return: List of vehicles with that type of fault.
     */
    public ArrayList<Vehicle> vehiclesWithTypeOfFault(String faultType) {
        ArrayList<Vehicle> vehiclesWithFault = new ArrayList<Vehicle>();
        for (Entry<String, Vehicle> entry: vehicleCollection.entrySet())
        {
            Vehicle currentVehicle = entry.getValue();
            ArrayList<String> currentVehicleFaultHistory = currentVehicle.getFaultHistory();
            for (int faultIndex = 0; faultIndex < currentVehicleFaultHistory.size(); faultIndex++)
            {
                Fault currentFault = faultCollection.get(currentVehicleFaultHistory.get(faultIndex));
                String currentFaultType = currentFault.getFaultType().toUpperCase();   
                if (currentFaultType.equals(faultType.toUpperCase()))
                {
                    vehiclesWithFault.add(currentVehicle);
                }
            }
        }
        return vehiclesWithFault;
    }

    /**
     * Method intended to find the most common fault.
     * @param a: ArrayList of faults
     * @return: The most common fault.
     */
    public Fault mostCommonFault() {
        int mostNumVehicles = Integer.MIN_VALUE;
        Fault mostCommon = null;
        for (Entry<String, Fault> entry: faultCollection.entrySet())
        {
            Fault currentFault = entry.getValue();
            int currentFaultNumVehicles = currentFault.getVehicles().size();
            if (currentFaultNumVehicles > mostNumVehicles)
            {
                mostNumVehicles = currentFaultNumVehicles;
                mostCommon = currentFault;
            }
        }
        return mostCommon;
    }

    /**
     * Method intended to find the rarest fault, the one with the least vehicles.
     * @param a: ArrayList of faults
     * @return: The rarest fault.
     */
    public Fault rarestFault() {
        int leastNumVehicles = Integer.MAX_VALUE;
        Fault rarest = null;
        for (Entry<String, Fault> entry: faultCollection.entrySet())
        {
            Fault currentFault = entry.getValue();
            int currentFaultNumVehicles = currentFault.getVehicles().size();
            if (currentFaultNumVehicles < leastNumVehicles)
            {
                leastNumVehicles = currentFaultNumVehicles;
                rarest = currentFault;
            }
        }
        return rarest;
    }

    /**
     * Method intended to return how many average faults per time window
     * @param a: Arraylist of faults
     * @param b: int
     * @return: the fault density in faults per time window.
     */
    public int faultDensity(TimeWindow timeWindow) {
        ArrayList<Fault> faultsInThisTimeWindow = new ArrayList<Fault>();
        for (Entry<String, Fault> entry: faultCollection.entrySet())
        {
            Fault currentFault = entry.getValue();
            if (currentFault.inTimeWindow(timeWindow))
            {
                faultsInThisTimeWindow.add(currentFault);
            }
        }
        int faultDensity = faultsInThisTimeWindow.size()/(int)timeWindow.totalTimeInWindow();
        return faultDensity;
    }

    /** Method intended to get the faults that happened around a given fault in a given vehicle. Whether the faults
     * are before or after the given fault depends on the boolean after. If it is set to true, the faults will be after,
     * and if it is false, the faults will be before. 
     * @param vehicle
     * @param faultID
     * @param timeWindow
     * @param after
     * @return Arraylist
     */
    public ArrayList<String> aroundFault(Vehicle vehicle, String faultID, TimeWindow timeWindow, boolean after)
    {
        ArrayList<String> aroundFault = new ArrayList<String>();
         int indexOfFault = indexOfFaultInVehicle(vehicle, faultID);
        // If statement prevents out of bounds error if the fault passed in is not in the vehicle's fault history.
        if (indexOfFault == -1)
        {
            return null;
        }
        if (after)
        {
            aroundFault = afterFault(vehicle, faultID, indexOfFault, timeWindow);
        }
        else
        {
            aroundFault = beforeFault(vehicle, faultID, indexOfFault, timeWindow);
        }
        return aroundFault;
    }

    /**
     * Method intended to return the faults after a certain fault was given up to the
     * paramater passed in.
     * @param a: fault
     * @param b: string
     * @param c: Timewindow
     * @return: Arraylist of fault IDs that happened after a fault.
     */
    public ArrayList<String> afterFault(Vehicle vehicle, String faultID, int indexOfFault, TimeWindow timeWindow) {
        ArrayList<String> afterFault = new ArrayList<String>();
        ArrayList<String> vehicleFaultHistory = vehicle.getFaultHistory();
        for (int faultIndex = indexOfFault; faultIndex < vehicleFaultHistory.size(); faultIndex++)
        {
            Fault currentFault = faultCollection.get(vehicleFaultHistory.get(faultIndex));
            TimeWindow currentFaultTimeWindow = currentFault.getTimeWindow();
            if (currentFaultTimeWindow.secondsClearedSince1970() <= timeWindow.secondsClearedSince1970())
            {
                afterFault.add(currentFault.getFaultID());
            }              
        }
        return afterFault;
    }

    /**
     * Method intended to return data before a certain fault was given up to the
     * @paramater passed in.
     * @param a: fault
     * @param b: string
     * @param c: Timewindow
     * @return: Arraylist of fault IDs that happened before a fault up to a certain
     * index.
     */
    public ArrayList<String> beforeFault(Vehicle vehicle, String faultID, int indexOfFault, TimeWindow timeWindow) {
        ArrayList<String> beforeFault = new ArrayList<String>();
        ArrayList<String> vehicleFaultHistory = vehicle.getFaultHistory();
        for (int faultIndex = indexOfFault; faultIndex < vehicleFaultHistory.size(); faultIndex++)
        {
            Fault currentFault = faultCollection.get(vehicleFaultHistory.get(faultIndex));
            TimeWindow currentFaultTimeWindow = currentFault.getTimeWindow();
            if (currentFaultTimeWindow.secondsClearedSince1970() >= timeWindow.secondsClearedSince1970())
            {
                beforeFault.add(currentFault.getFaultID());
            }              
        }
        return beforeFault;
    }

    /** Method intended to look for a faultID in a vehicle's fault history. Uses a while loop
     * so that the system can break out of the loop once the ID is found. 
     * @param vehicle
     * @param faultID
     * @return
     */
    public int indexOfFaultInVehicle(Vehicle vehicle, String faultID)
    {
        ArrayList<String> vehicleFaultHistory = new ArrayList<String>();
        int faultIndex = 0;
        boolean found = false;
        int placeOfFaultID = -1;
        while (faultIndex < vehicleFaultHistory.size() && !found)
        {
            if (vehicleFaultHistory.get(faultIndex).equals(faultID))
            {
                placeOfFaultID = faultIndex;
                found = true;
            }
        }
        return placeOfFaultID;
    }

    /**
     * Method intended to find the correlation between the aspect and the fault data
     * and the fault data when aspect is a string array
     * This method won't return r as that can't be calculated here. Instead, an
     * example of what this method would return would be is
     * if the aspect is the factory from which the car was manufactured, the method
     * will return which factory made the cars with the
     * most faults.
     * @param a: String array
     * @param b: int array
     * @return: Whichever factory, model, or anything else the aspect could be, has
     * the most faults.
     */
    public String aspectFaultDataQualatitive(String[] aspect, int[] faultData) {
        return null;

    }

    /**
     * Method intended to find the subsystem of cars with the most faults
     * @param
     * @return: the subsystem with the most faults.
     */
    public SubSystem mostBadlyFaultedSubSystem() {
        int maxNumFaults = Integer.MIN_VALUE;
        SubSystem mostBadlyFaulted = null;
        for (Entry<String, SubSystem> entry: subSystemCollection.entrySet())
        {
            SubSystem currentSubSystem = entry.getValue();
            int currentSubSystemNumFaults = currentSubSystem.getFaultsInThisSubSystem().size();
            if (currentSubSystemNumFaults > maxNumFaults)
            {
                maxNumFaults = currentSubSystemNumFaults;
                mostBadlyFaulted = currentSubSystem;
            }
        }
        return mostBadlyFaulted;
    }


     @Override
     public <E, T> LinkedList<T> createDataList(HashMap<String, E> dataGiver, String dataName, int numOfSamples, boolean systematic) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        LinkedList<T> toReturn = new LinkedList<T>();
        @SuppressWarnings("unchecked")
        E[] valsOfMap = (E[]) dataGiver.values().toArray();
        // samplingInterval used for systematic smapling but can help calculate starting point also. 
            int samplingInterval = valsOfMap.length/numOfSamples;
            int startingPoint = (int) (Math.random()*numOfSamples);
            int EIndex = startingPoint; 
        for (int dataIndex = 0; dataIndex < numOfSamples; dataIndex++)
        {
            if (!systematic)
            {
                // Will do random sampling if systematic is false.
                // Checked with client, the probablilty that a sample is chosen twice is negligibly low.
                EIndex = (int) (Math.random()*valsOfMap.length);
            }
            else
            {
                if (dataIndex != 0)
                {
                    EIndex += samplingInterval;
                }
            }
            ArrayList<Method> accessorMethods = accessorMethodsFromObject(valsOfMap[EIndex]);
            for (int methodIndex = 0; methodIndex < accessorMethods.size(); methodIndex++)
            {
                Method currentMethod = accessorMethods.get(methodIndex);
                String methodName = currentMethod.getName().toUpperCase();
                String dName = dataName.toUpperCase(); 
                if (methodName.contains(dName))
                {
                    Object attributeValue = currentMethod.invoke(valsOfMap[EIndex]);
                    @SuppressWarnings("unchecked")
                    T attributeValueGeneric = (T) attributeValue;
                    toReturn.add(attributeValueGeneric);
                }
            }
        }
        return toReturn;
    }

    /** Method intended to take any object and return a list of its accessor methods. 
     * @param <E>
     * @param o
     * @return ArrayList<Method>
     */
    public <E> ArrayList<Method> accessorMethodsFromObject(E o)
    {
        // Gets the class of the object.
        Class<?> objClass = o.getClass();

        // Takes the methods of the object.
        Method[] allMethods =  objClass.getDeclaredMethods();

        /* Creates a new list that will contain the accessor methods of the object.
        *  It is a list so that the size can be changed to adjust how many accessor methods are in the object. 
        */
        ArrayList<Method> accessorMethods = new ArrayList<Method>();

        // Iterates through array of all methods.
        for (int methodIndex = 0; methodIndex < allMethods.length; methodIndex++)
        {
            // The method the list is currently pointing to.
            Method currentMethod = allMethods[methodIndex];
            // Only adds the the new list if it is a accessor method. 
            if (isAccessor(currentMethod))
            {
                accessorMethods.add(currentMethod);
            }
        }
        return accessorMethods;
    }
   
    
    /** Method intended to check if the method passed in is a getter method.
     * @param method
     * @return boolean
     */
    public boolean isAccessor(Method method) 
    {
        String methodName = method.getName();
        return methodName.startsWith("get") && !methodName.equals("getClass") && method.getParameterCount() == 0;
    }

    /** Method intended to perform a merge sort on any given list. This will be used for all lists,
     * as an O(nlog(n)) search is the most efficient sorting method, especially given how big the will be. 
     * @param <E>
     * @param toSort
     * @return a sorted list
     */
    public Double[] sortListMerge(Double[] toSort)
    {
        int listLength = toSort.length;
        // Array can't be divided into halves if it is less than 2 elements long.
        if (toSort.length < 2)
        {
            return toSort;
        }
        int midPoint = listLength/2;
        Double[] left = new Double[midPoint];
        Double[] right = new Double[listLength - midPoint]; 

        for (int sortIndex = 0; sortIndex < midPoint; sortIndex++)
        {
            left[sortIndex] = toSort[sortIndex];
        }

        for (int sortIndex = midPoint; sortIndex < listLength; sortIndex++)
        {
            right[sortIndex - midPoint] = toSort[sortIndex];
        }

        left = sortListMerge(left);
        right = sortListMerge(right);

        Double[] result = merge(left, right);
        return result;
    }

    /** Method intended to merge left and right after they have been sorted and return the full, sorted array. 
     * @param left
     * @param right
     * @return
     */
    public Double[] merge(Double[] left, Double[] right)
    {
        Double[] sortedArray = new Double[left.length + right.length];
        int leftIndex = 0, rightIndex = 0, sortedIndex = 0;
        
        while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex] <= right[rightIndex]) {
                sortedArray[sortedIndex] = left[leftIndex];
                leftIndex++;
            } else {
                    sortedArray[sortedIndex] = right[rightIndex];
                rightIndex++;
            }
            sortedIndex++;
        }

        while (leftIndex < left.length) {
            sortedArray[sortedIndex] = left[leftIndex];
            leftIndex++;
            sortedIndex++;
        }

        while (rightIndex < right.length) {
            sortedArray[sortedIndex] = right[rightIndex];
            rightIndex++;
            sortedIndex++;
        }

        return sortedArray;
    }

    public double maxNumber(Double[] list)
    {
        double max = Double.MIN_VALUE;
        for (int listIndex = 0; listIndex < list.length; listIndex++)
        {
            if (list[listIndex] > max)
            {
                max = list[listIndex];
            }
        }
        return max;
    }

    @Override
    public double mean(LinkedList<Double> data) 
    {
        double sum = Double.MIN_VALUE;
        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++)
        {
            sum += data.get(dataIndex);
        }
        double result = sum/data.size();
        return result;
    }

    @Override
    public double standardDeviation(LinkedList<Double> data) 
    {
        double sum = Double.MIN_VALUE;
        double mean = mean(data);
        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++)
        {
            sum += Math.pow((data.get(dataIndex) - mean), 2.0);
        }    
        return Math.sqrt(sum/(data.size() - 1.0));
    }

    @Override
    public double median(LinkedList<Double> data)
     {
        /*
         * The if statement states that if the length of the list is an odd number, it
         * will use the middle value, and if the length of the list is an even number,
         * it will find the mean of the 2 values closest to the middle. 
         */ 
        if (data.size() % 2 != 0)
        {
            return (data.get(data.size()/2));
        }
        else
        {
            return (data.get((data.size()/2)-1) + (data.get(data.size()/2)))/2;
        }
    }

    @Override
    public double mode(LinkedList<Double> data) {
        // Hashmap stores the data point as the key and its frequency as its value.
        HashMap<Double, Integer> frequencyList = new HashMap<Double, Integer>();

        frequencyList = numsAndFrequencies(data);

        double maxFrequency = Double.MIN_VALUE;
        double mode = Double.MIN_VALUE;

        for (HashMap.Entry<Double, Integer> entry : frequencyList.entrySet())
        {
            double value = entry.getKey();
            double freq = entry.getValue();
            if (freq > maxFrequency)
            {
                maxFrequency = freq;
                mode = value;
            }
        }
        if (!allSameVals(frequencyList))
        {
            return mode;
        }
        else return -1;
    }

    /** Method intended to create a hashmap with the key being an element in a list and the value being the frequency.
     * @param <E>
     * @param data
     * @return hashmap 
     */ 
    public <E> HashMap<E, Integer> numsAndFrequencies(LinkedList<E> data)
    {
        // Hashmap stores the data point as the key and its frequency as its value.
        HashMap<E, Integer> frequencyList = new HashMap<E, Integer>();

        for (int dataIndex = 0; dataIndex < data.size(); dataIndex++)
        {
            E thisData = data.get(dataIndex);
            frequencyList.put(thisData, frequencyList.getOrDefault(thisData, 0) + 1);
        }
        return frequencyList;
    }

    @Override
    public double aspectFaultCorrelation(LinkedList<Double> dataX, LinkedList<Double> dataY) {
        double sumNum = Double.MIN_VALUE;
        double sumDenX = Double.MIN_VALUE;
        double sumDenY = Double.MIN_VALUE;
        double meanX = mean(dataX);
        double meanY = mean(dataY);
        for (int dataIndex = 0; dataIndex < dataX.size(); dataIndex++)
        {
            double xCalc1 = (dataX.get(dataIndex) - meanX);
            double yCalc1 = (dataY.get(dataIndex) - meanY);
            double totalOfAll1 = xCalc1*yCalc1;
            sumNum += totalOfAll1;
            double xCalc2 = Math.pow(xCalc1, 2.0);
            sumDenX += xCalc2;
            double yCalc2 = Math.pow(yCalc1, 2.0);
            sumDenY += yCalc2;
        }
        double result = sumNum/(Math.sqrt(sumDenX*sumDenY));
        return result; 
    }

    @Override
    public double skew(LinkedList<Double> data) {
        double sum = Double.MIN_VALUE;
        double mean = mean(data);
        double n = data.size();
        for (int dataIndex = 0; dataIndex < n; dataIndex++)
        {
            double numerator = data.get(dataIndex) - mean;
            double denominator = standardDeviation(data);
            double quotient = numerator/denominator;
            double toAdd = Math.pow(quotient, 3);
            sum += toAdd;
        }

        double skew = sum*(n/((n-1)*(n-2)));
        return skew;
    }

    @Override
    public String regressionEquation(LinkedList<Double> dataX, LinkedList<Double> dataY) {
        double meanX = mean(dataX);
        double meanY = mean(dataY);
        double b = aspectFaultCorrelation(dataX, dataY)*(standardDeviation(dataY)/standardDeviation(dataX));
        double a = meanY - b*meanX;
        String equation = "y = " + b + "x + " + a;
        return equation; 
    }

    @Override
    public void removeOutliers(LinkedList<Double> dataIn) {
        // Converts the linked list to an array so that it can be sorted.
        Double[] dataArray = dataIn.toArray(new Double[dataIn.size()]);
        Double[] dataArraySorted = sortListMerge(dataArray);
        // Converts sorted list back to array.
        LinkedList<Double> data = convertArrayToLinkedList(dataArraySorted);
        boolean noMoreOutliers = false;
        while (!noMoreOutliers)
        {
            double firstPoint = data.getFirst();
            double lastPoint = data.getLast();
            if (!isOutlier(data, firstPoint) && !isOutlier(data, lastPoint))
            {
                noMoreOutliers = true;
            }
            else
            {
                if (isOutlier(data, firstPoint))
                {
                    data.removeFirst();
                }
                if (isOutlier(data, lastPoint))
                {
                    data.removeLast();
                }
            }
        }
    }

    @Override
    public boolean isOutlier(LinkedList<Double> data, double dataPoint) {
        double lowerBound = mean(data) - (2*standardDeviation(data));
        double upperBound = mean(data) + (2*standardDeviation(data));
        return (dataPoint > upperBound) ^ (dataPoint < lowerBound);        
    }

    /** Method intended to convert any array into a linked list. This will 
     * often need to be done, so this method is written for the sake of
     * code reusability.
     * @param <E>
     * @param array
     * @return LinkedList converted from an array
     */
    public <E> LinkedList<E> convertArrayToLinkedList(E[] array)
    {
        LinkedList<E> data = new LinkedList<E>();
        for (E index : array)
        {
            data.add(index);
        }
        return data;
    }

    /** Method intended to state whether a hasmpa hase the same values for all keys.
     * @param <K>
     * @param <V>
     * @param map
     * @return Whether all values in this map are the same or not.
     */
    public <K, V> boolean allSameVals(Map<K, V> map)
    {
        if (map.isEmpty())
        {
            return true;
        }

        V firstVal = map.values().iterator().next();
        for (V value: map.values())
        {
            if (!value.equals(firstVal))
            {
                return false;
            }
        }
        return true;
    }
}